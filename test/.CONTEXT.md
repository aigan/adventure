# Test Suite Context

Comprehensive test coverage (~2,400 lines across 13+ test files) using Mocha test framework.

## Running Tests

```bash
npm test                                  # Run full suite (sets NODE_ENV=test to filter logging)
mocha test/belief.test.mjs                # Run specific file
mocha --grep "archetype"                  # Run tests matching pattern
NODE_ENV=test mocha test/belief.test.mjs  # Run with logging filtered
```

**Note**: `npm test` sets `NODE_ENV=test` which filters runtime logging. Add `NODE_ENV=test` when running mocha directly if you need the same behavior.

## Test Structure

### Core Class Tests
- `mind.test.mjs` - Mind creation, state management, label lookups, nesting, serialization
- `belief.test.mjs` - Belief construction, archetype inheritance, trait validation, serialization
- `state.test.mjs` - State immutability, tick operations, belief queries, inheritance

### System Tests
- `archetype.test.mjs` - Archetype composition, single/multiple inheritance, trait resolution
- `traittype.test.mjs` - Trait type resolution (primitives, belief refs, containers)
- `learn_about.test.mjs` - Cross-mind learning, dereferencing, trait copying
- `declarative_mind_state.test.mjs` - State.resolve_template(), learning specs

### Integration Tests
- `integration.test.mjs` - Full system scenarios matching world.mjs setup
- `inspect.test.mjs` - Inspection UI rendering and navigation
- `channel.test.mjs` - BroadcastChannel communication and serialization
- `registry.test.mjs` - Global registries, ID sequences, label uniqueness

### Message Protocol Tests
- `message_protocol.test.mjs` - Message format validation (no mocking needed)
- `worker_mock.test.mjs` - Communication flow with MockWorker API simulation
- `worker_dispatch.test.mjs` - Real worker.mjs dispatch logic testing

**Message Protocol Coverage:**
- Client → Worker message format: `['command', data, ackid]`
- Worker → Client message formats: `ack`, `header_set`, `main_clear`, `main_add`, `topic_update`
- Data structures: SubjectData, ActionData, TemplateTagResult
- Promise-based request/response patterns
- Round-trip communication flow
- Error handling and edge cases

**MockWorker Class** (`worker_mock.test.mjs`):
Simulates Worker API for testing communication patterns without browser:
```javascript
class MockWorker {
  postMessage(data)                    // Send to worker
  addEventListener(type, handler)      // Listen for worker events
  simulateWorkerMessage(data)         // Simulate worker response
  onmessage: (event) => {}            // Main thread handler
}
```

**Worker Dispatch Tests** (`worker_dispatch.test.mjs`):
Tests actual `worker.mjs` by mocking global Worker environment:
- Mocks `global.postMessage`, `global.addEventListener`, `global.self`
- Imports real worker.mjs to test dispatch logic
- Verifies built-in handlers (ping, start)
- Tests custom handler registration
- Validates message format parsing and ack responses

All message protocol tests run in Node.js without requiring a browser.

## Test Utilities (`helpers.mjs`)

### `setupStandardArchetypes()`
Creates archetype hierarchy matching `public/worker/world.mjs`.

**Creates**:
- ObjectPhysical (base)
- Location (extends ObjectPhysical)
- PortableObject (extends ObjectPhysical)
- Mental (extends ObjectPhysical)
- Actor (extends ObjectPhysical)
- Player (extends Actor + Mental)

**Use case**: Integration tests and tests requiring full system

### `setupMinimalArchetypes()`
Lightweight setup for focused tests.

**Creates**:
- Base archetype only
- Minimal trait types

**Use case**: Unit tests for specific features

### `createMindWithBeliefs(beliefs)`
Helper for quick mind creation with beliefs.

**Parameters**:
- `beliefs` - Array of belief specs

**Returns**: Mind instance with beliefs added

**Use case**: Setting up test fixtures quickly

## Test Patterns

```javascript
import { setupStandardArchetypes } from './helpers.mjs'

describe('Feature Name', () => {
  beforeEach(() => {
    setupStandardArchetypes()
  })

  it('should do something specific', () => {
    const mind = Materia.create_world()
    const state1 = mind.create_state(DB.get_logos_state(), {tt: 1})
    const belief = Belief.from_template(state1, {
      bases: ['PortableObject'],
      traits: {'@label': 'test'}
    })
    state1.lock()

    const state2 = state1.branch_state(DB.get_logos_state(), 2)

    assert.notStrictEqual(state1, state2)  // Immutability
    assert.strictEqual([...state2.get_beliefs()].length, 1)
  })
})
```

**Conventions**:
- Describe blocks: Feature or class name
- Test names: "should" + specific behavior
- Use descriptive variable names
- Test both success and failure cases

## Requirements

- Every new feature needs tests
- Test edge cases and error conditions
- Use `helpers.mjs` for consistent setup
- Keep tests focused and independent
- All tests must pass before merging

## Debugging

```bash
mocha test/belief.test.mjs              # Run specific file
mocha --grep "archetype composition"    # Filter by pattern
mocha --reporter spec test/*.test.mjs   # Verbose output
```

## References

- [docs/IMPLEMENTATION.md](../docs/IMPLEMENTATION.md) - Implementation architecture
- [docs/STYLE.md](../docs/STYLE.md) - Code quality checklist
- [public/worker/.CONTEXT.md](../public/worker/.CONTEXT.md) - Worker modules
- Mocha docs: https://mochajs.org/
